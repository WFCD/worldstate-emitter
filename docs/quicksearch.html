<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"handlers_Worldstate.js.html":{"id":"handlers_Worldstate.js.html","title":"Source: handlers/Worldstate.js","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Source: handlers/Worldstate.js 'use strict'; const Cache = require('json-fetch-cache'); const { locales } = require('warframe-worldstate-data'); const WSCache = require('../utilities/WSCache'); const { logger, groupBy, lastUpdated } = require('../utilities'); const wsTimeout = process.env.CACHE_TIMEOUT || 60000; const platforms = ['pc', 'ps4', 'xb1', 'swi']; const worldStates = {}; const wsRawCaches = {}; const debugEvents = ['arbitration', 'kuva', 'nightwave']; const smTimeout = process.env.SEMLAR_TIMEOUT || 300000; const kuvaCache = new Cache('https://10o.io/kuvalog.json', smTimeout, { logger, maxRetry: 0 }); const sentientCache = new Cache('https://semlar.com/anomaly.json', smTimeout, { logger }); const fissureKey = (fissure) =&gt; `fissures.t${fissure.tierNum}.${(fissure.missionType || '').toLowerCase()}`; const acolyteKey = (acolyte) =&gt; ({ eventKey: `enemies${acolyte.isDiscovered ? '' : '.departed'}`, activation: acolyte.lastDiscoveredAt, }); const arbiKey = (arbitration) =&gt; { if (!(arbitration &amp;&amp; arbitration.enemy)) return ''; let k; try { k = `arbitration.${arbitration.enemy.toLowerCase()}.${arbitration.type.replace(/\\s/g, '').toLowerCase()}`; } catch (e) { logger.error(`Unable to parse arbitraion: ${JSON.stringify(arbitration)}\\n${e}`); } return k; }; const eKeyOverrides = { events: 'operations', persistentEnemies: 'enemies', fissures: fissureKey, enemies: acolyteKey, arbitration: arbiKey, }; /** * Find overrides for the provided key * @param {string} key worldsate field to find overrides * @param {Object} data data corresponding to the key from provided worldstate * @returns {string} overrided key */ const checkOverrides = (key, data) =&gt; { if (typeof eKeyOverrides[key] === 'string') { return eKeyOverrides[key]; } if (typeof eKeyOverrides[key] === 'function') { return eKeyOverrides[key](data); } return key; }; /** * Process kuva fields * @param {Object} deps dependencies for processing * @param {Object[]} packets packets to emit * @returns {Object|Object[]} object(s) to emit from kuva stuff */ const kuvaProcessing = (deps, packets) =&gt; { if (!deps.data) { logger.error('no kuva data'); return undefined; } const data = groupBy(deps.data, 'type'); Object.keys(data).forEach((type) =&gt; { deps = { ...deps, data: data[type], id: `kuva.${data[type][0].type.replace(/\\s/g, '').toLowerCase()}`, activation: data[type][0].activation, expiry: data[type][0].expiry, }; const p = require('./events/objectLike')(deps.data, deps); if (p) { packets.push(p); } }); return packets.filter((p) =&gt; p); }; /** * arrayLike are all just arrays of objectLike * @param {Object} deps dependencies for processing * @param {Object[]} packets packets to emit * @returns {Object|Object[]} object(s) to emit from arrayLike processing */ const arrayLike = (deps, packets) =&gt; { deps.data.forEach((arrayItem) =&gt; { const k = checkOverrides(deps.key, arrayItem); packets.push(require('./events/objectLike')(arrayItem, { ...deps, id: k, })); }); return packets; }; /** * Set up current cycle start if it's not been intiated * @param {Object} deps dependencies for processing */ const initCycleStart = (deps) =&gt; { if (!lastUpdated[deps.platform][deps.language]) { lastUpdated[deps.platform][deps.language] = deps.cycleStart; } }; /** * Parse new events from the provided worldstate * @param {Object} deps dependencies to parse out events * @returns {Packet|Packet[]} packet(s) to emit */ const parseNew = (deps) =&gt; { initCycleStart(deps); // anything in the eKeyOverrides goes first, then anything uniform const packets = []; switch (deps.key) { case 'kuva': return kuvaProcessing(deps, packets); case 'events': deps = { ...deps, id: eKeyOverrides[deps.key], }; case 'alerts': case 'conclaveChallenges': case 'dailyDeals': case 'flashSales': case 'fissures': case 'globalUpgrades': case 'invasions': case 'syndicateMissions': case 'weeklyChallenges': packets.push(...arrayLike(deps, packets)); break; case 'cetusCycle': case 'earthCycle': case 'vallisCycle': packets.push(require('./events/cycleLike')(deps.data, deps)); break; case 'persistentEnemies': deps = { ...deps, ...checkOverrides(deps.key, deps.data), }; case 'sortie': case 'voidTrader': case 'arbitration': case 'sentientOutposts': deps.id = checkOverrides(deps.key, deps.data); packets.push(require('./events/objectLike')(deps.data, deps)); case 'nightwave': packets.push(require('./events/nightwave')(deps.data, deps)); default: break; } return packets; }; /** * Handler for worldstate data */ class Worldstate { /** * Set up listening for specific platform and locale if provided. * @param {EventEmitter} eventEmitter Emitter to push new worldstate events to * @param {string} platform Platform to watch (optional) * @param {string} locale Locale (actually just language) to watch */ constructor(eventEmitter, platform, locale) { this.emitter = eventEmitter; this.platform = platform; this.locale = locale; logger.silly('starting up worldstate listener...'); if (platform) { logger.debug(`only listening for ${platform}...`); } if (locale) { logger.debug(`only listening for ${locale}...`); } this.setUpRawEmitters(); this.setupParsedEvents(); } /** * Set up emitting raw worldstate data */ setUpRawEmitters() { platforms.forEach((p) =&gt; { if (this.platform &amp;&amp; this.platform !== p) return; const url = `http://content${p === 'pc' ? '' : `.${p}`}.warframe.com/dynamic/worldState.php`; worldStates[p] = {}; locales.forEach(async (locale) =&gt; { if (!this.locale || this.locale === locale) { worldStates[p][locale] = new WSCache({ platform: p, locale, kuvaCache, sentientCache, eventEmitter: this.emitter, }); } }); wsRawCaches[p] = new Cache(url, wsTimeout, { delayStart: false, parser: (str) =&gt; str, useEmitter: true, logger, }); /* listen for the raw cache updates so we can emit them from the super emitter */ wsRawCaches[p].on('update', (dataStr) =&gt; { this.emitter.emit('ws:update:raw', { platform: p, data: dataStr }); }); }); /* when the raw emits happen, parse them and store them on parsed worldstate caches */ this.emitter.on('ws:update:raw', ({ platform, data }) =&gt; { locales.forEach((locale) =&gt; { if (!this.locale || this.locale === locale) { worldStates[platform][locale].data = data; } }); }); } /** * Set up listeners for the parsed worldstate updates */ setupParsedEvents() { this.emitter.on('ws:update:parsed', ({ language, platform, data }) =&gt; { const packet = { platform, worldstate: data, language }; this.parseEvents(packet, this.emitter); }); } /** * Parse new worldstate events * @param {Object} worldstate worldstate to find packets from * @param {string} platform platform the worldstate corresponds to * @param {string} [language='en'] langauge of the worldstate (defaults to 'en') */ parseEvents({ worldstate, platform, language = 'en' }) { const cycleStart = Date.now(); const packets = []; Object.keys(worldstate).forEach(async (key) =&gt; { const packet = parseNew({ data: worldstate[key], key, language, platform, cycleStart, }); if (Array.isArray(packet)) { if (packet.length) { packets.push(...(packet.filter((p) =&gt; p &amp;&amp; p !== null))); } } else if (packet) { packets.push(packet); } }); lastUpdated[platform][language] = Date.now(); packets .filter((p) =&gt; p &amp;&amp; p.id &amp;&amp; packets !== null) .forEach((packet) =&gt; { this.emit('ws:update:event', packet); }); } /** * Emit an event with given id * @param {string} id Id of the event to emit * @param {Object} packet Data packet to emit */ emit(id, packet) { if (debugEvents.includes(packet.key)) logger.warn(packet.key); logger.silly(`ws:update:event - emitting ${packet.id}`); delete packet.cycleStart; this.emitter.emit(id, packet); } /** * get a specific worldstate version * @param {string} [platform='pc'] Platform of the worldstate * @param {string} [locale='en'] Locale of the worldsttate * @returns {Object} Worldstate corresponding to provided data * @throws {Error} when the platform or locale aren't tracked and aren't updated */ // eslint-disable-next-line class-methods-use-this get(platform = 'pc', language = 'en') { if (worldStates[platform] &amp;&amp; worldStates[platform][language]) { return worldStates[platform][language].data; } throw new Error(`Platform (${platform}) or language (${language}) not tracked.\\nEnsure that the parameters passed are correct`); } } module.exports = Worldstate; × Search results Close "},"utilities_index.js.html":{"id":"utilities_index.js.html","title":"Source: utilities/index.js","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Source: utilities/index.js 'use strict'; require('colors'); const { transports, createLogger, format } = require('winston'); const { combine, label, printf, colorize, } = format; /* Logger setup */ const transport = new transports.Console({ colorize: true }); const logFormat = printf((info) =&gt; `[${info.label}] ${info.level}: ${info.message}`); const logger = createLogger({ format: combine( colorize(), label({ label: 'WS'.brightBlue }), logFormat, ), transports: [transport], }); logger.level = process.env.LOG_LEVEL || 'error'; /** * Group an array by a field value * @param {Object[]} array array of objects to broup * @param {string} field field to group by * @returns {Object} [description] */ const groupBy = (array, field) =&gt; { const grouped = {}; if (!array) return undefined; array.forEach((item) =&gt; { const fVal = item[field]; if (!grouped[fVal]) { grouped[fVal] = []; } grouped[fVal].push(item); }); return grouped; }; const allowedDeviation = 30000; /** * Validate that b is between a and c * @param {Date} a The first Date, should be the last time things were updated * @param {Date} b The second Date, should be the activation time of an event * @param {Date} c The third Date, should be the start time of this update cycle * @returns {boolean} if the event date is between the server start time and the last update time */ const between = (a, b, c = new Date()) =&gt; (b + allowedDeviation &gt; a) &amp;&amp; (b - allowedDeviation &lt; c); /** * Returns the number of milliseconds between now and a given date * @param {string} d The date from which the current time will be subtracted * @param {function} [now] A function that returns the current UNIX time in milliseconds * @returns {number} */ function fromNow(d, now = Date.now) { return new Date(d).getTime() - now(); } /** * Map of last updated dates/times * @type {Object} */ const lastUpdated = { pc: { en: 0, // Date.now(), }, ps4: { en: Date.now(), }, xb1: { en: Date.now(), }, swi: { en: Date.now(), }, }; module.exports = { logger, groupBy, fromNow, between, lastUpdated, }; × Search results Close "},"handlers_RSS.js.html":{"id":"handlers_RSS.js.html","title":"Source: handlers/RSS.js","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Source: handlers/RSS.js 'use strict'; const RssFeedEmitter = require('rss-feed-emitter'); const feeds = require('../resources/rssFeeds.json'); const { logger } = require('../utilities'); /** * RSS Emitter, leverages [rss-feed-emitter](https://npmjs.org/package/rss-feed-emitter) */ class RSS { /** * Set up emitting events for warframe forum entries * @param {EventEmitter} eventEmitter Emitter to send events from */ constructor(eventEmitter) { this.logger = logger; this.emitter = eventEmitter; this.feeder = new RssFeedEmitter({ userAgent: 'WFCD Feed Notifier', skipFirstLoad: true, }); feeds.forEach((feed) =&gt; { this.feeder.add({ url: feed.url, timeout: 30000 }); }); this.logger.debug('RSS Feed active'); this.start = Date.now(); this.feeder.on('error', this.logger.error); this.feeder.on('new-item', this.handleNew.bind(this)); } handleNew(item) { try { if (Object.keys(item.image).length) { this.logger.debug(`Image: ${JSON.stringify(item.image)}`); } if (new Date(item.pubDate).getTime() &lt;= this.start) return; const feed = feeds.filter((feedEntry) =&gt; feedEntry.url === item.meta.link)[0]; let firstImg = ((item.description || '').match(/&lt;img.*src=\"(.*)\".*&gt;/i) || [])[1]; if (!firstImg) { firstImg = feed.defaultAttach; } else if (firstImg.startsWith('//')) { firstImg = firstImg.replace('//', 'https://'); } const rssSummary = { body: (item.description || '\\u200B').replace(/&lt;(?:.|\\n)*?&gt;/gm, '').replace(/\\n\\n+\\s*/gm, '\\n\\n'), url: item.link, timestamp: item.pubDate, description: item.meta.description, author: feed.author || { name: 'Warframe Forums', url: item['rss:link']['#'], icon_url: 'https://i.imgur.com/hE2jdpv.png', }, title: item.title, image: firstImg, id: feed.key, }; this.emitter.emit('rss', rssSummary); } catch (error) { this.logger.error(error); } } } module.exports = RSS; × Search results Close "},"handlers_Twitter.js.html":{"id":"handlers_Twitter.js.html","title":"Source: handlers/Twitter.js","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Source: handlers/Twitter.js 'use strict'; const Twitter = require('twitter'); const toWatch = require('../resources/tweeters.json'); const { logger } = require('../utilities'); const determineTweetType = (tweet) =&gt; { if (tweet.in_reply_to_status_id) { return ('reply'); } if (tweet.quoted_status_id) { return ('quote'); } if (tweet.retweeted_status) { return ('retweet'); } return ('tweet'); }; const parseAuthor = (tweet) =&gt; ({ name: tweet.user.name, handle: tweet.user.screen_name, url: `https://twitter.com/${tweet.user.screen_name}`, avatar: `${tweet.user.profile_image_url.replace('_normal.jpg', '.jpg')}`, }); const parseQuoted = (tweet, type) =&gt; (tweet[type] ? { text: tweet[type].full_text, author: { name: tweet[type].user.name, handle: tweet[type].user.screen_name, }, } : undefined); const parseTweet = (tweets, watchable) =&gt; { const [tweet] = tweets; const type = determineTweetType(tweet); return { id: `twitter.${watchable.plain}.${type}`, uniqueId: String(tweets[0].id_str), text: tweet.full_text, url: `https://twitter.com/${tweet.user.screen_name}/status/${tweet.id_str}`, mediaUrl: tweet.entities.media ? tweet.entities.media[0].media_url : undefined, isReply: typeof tweet.in_reply_to_status_id !== 'undefined', author: parseAuthor(tweet), quote: parseQuoted(tweet, 'quoted_status'), retweet: parseQuoted(tweet, 'retweeted_status'), createdAt: new Date(tweet.created_at), tweets, }; }; /** * Twitter event handler */ class TwitterCache { /** * Create a new Twitter self-updating cache * @param {EventEmitter} eventEmitter emitter to push new tweets to */ constructor(eventEmitter) { this.emitter = eventEmitter; this.timeout = process.env.TWITTER_TIMEOUT || 60000; this.initTime = Date.now(); const clientInfo = { consumer_key: process.env.TWITTER_KEY, consumer_secret: process.env.TWITTER_SECRET, bearer_token: process.env.TWITTER_BEARER_TOKEN, }; this.clientInfoValid = clientInfo.consumer_key &amp;&amp; clientInfo.consumer_secret &amp;&amp; clientInfo.bearer_token; this.initClient(clientInfo); } initClient(clientInfo) { try { if (this.clientInfoValid) { this.client = new Twitter(clientInfo); // don't attempt anything else if authentication fails this.toWatch = toWatch; this.currentData = null; this.lastUpdated = Date.now() - 60000; this.updateInterval = setInterval(() =&gt; this.update(), this.timeout); this.update(); } else { logger.warn(`Twitter client not initialized... invalid token: ${clientInfo.bearer_token}`); } } catch (err) { this.client = undefined; this.clientInfoValid = false; logger.error(err); } } /** * Force the cache to update * @returns {Promise} the currently updating promise. */ async update() { if (!this.clientInfoValid) return undefined; if (!this.toWatch) { logger.verbose('Not processing twitter, no data to watch.'); return undefined; } if (!this.client) { logger.verbose('Not processing twitter, no client to connect.'); return undefined; } this.updating = this.getParseableData(); return this.updating; } /** * Get data able to be parsed from twitter. * @returns {Promise.&lt;Array.&lt;Object&gt;&gt;} Twieets */ async getParseableData() { logger.silly('Starting Twitter update...'); const parsedData = []; try { for (const watchable of this.toWatch) { const tweets = await this.client.get('statuses/user_timeline', { screen_name: watchable.acc_name, tweet_mode: 'extended', count: 1, }); const tweet = parseTweet(tweets, watchable); parsedData.push(tweet); if (tweet.createdAt.getTime() &gt; this.lastUpdated) { this.emitter.emit('tweet', tweet); } } } catch (error) { this.onError(error); } this.lastUpdated = Date.now(); return parsedData; } /** * Handle errors that arise while fetching data from twitter * @param {[type]} error twitter error */ onError(error) { if (error[0] &amp;&amp; error[0].code === 32) { this.clientInfoValid = false; logger.info('wiping twitter client data, could not authenticate...'); } else { logger.debug(JSON.stringify(error)); } } /** * Get the current data or a promise with the current data * @returns {Promise.&lt;Object&gt; | Object} either the current data * if it's not updating, or the promise returning the new data */ async getData() { if (!this.clientInfoValid) return undefined; if (this.updating) { return this.updating; } return this.currentData; } } module.exports = TwitterCache; × Search results Close "},"utilities_WSCache.js.html":{"id":"utilities_WSCache.js.html","title":"Source: utilities/WSCache.js","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Source: utilities/WSCache.js 'use strict'; const Worldstate = require('warframe-worldstate-parser'); /** * Warframe WorldState Cache - store and retrieve current worldstate data */ class WSCache { /** * Set up a cache checking for data and updates to a specific worldstate set * @param {string} platform Platform to track * @param {string} language Langauge/translation to track * @param {JSONCache} kuvaCache Cache of kuva data, provided by Semlar * @param {JSONCache} sentientCache Cache of sentient outpost data, provided by Semlar * @param {Eventemitter} eventEmitter Emitter to push new worldstate updates to */ constructor({ platform, language, kuvaCache, sentientCache, eventEmitter, }) { this.inner = null; Object.defineProperty(this, 'inner', { enumerable: false, configurable: false }); this.kuvaCache = kuvaCache; Object.defineProperty(this, 'kuvaCache', { enumerable: false, configurable: false }); this.sentientCache = sentientCache; Object.defineProperty(this, 'sentientCache', { enumerable: false, configurable: false }); this.platform = platform; this.language = language; this.emitter = eventEmitter; } /** * Get the latest worldstate data from this cache * @returns {Object} Current worldstate data */ get data() { return this.inner; } /** * Set the current data, aslso parses and emits data * @param {string} newData New string data to parse */ set data(newData) { setTimeout(async () =&gt; { const t = new Worldstate(newData, { locale: this.language, kuvaData: await this.kuvaCache.getData(), sentientData: await this.sentientCache.getData(), }); if (!t.timestamp) return; this.inner = t; this.emitter.emit('ws:update:parsed', { language: this.language, platform: this.platform, data: this.inner }); }, 1000); } /** * Set the current twitter data for the worldstate * @param {Object} newTwitter twitter data */ set twitter(newTwitter) { if (!(newTwitter &amp;&amp; newTwitter.length)) return; this.inner.twitter = newTwitter; } } module.exports = WSCache; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Global Members &lt;constant&gt; lastUpdated :Object Map of last updated dates/times Type: Object Source: utilities/index.js, line 66 Methods arrayLike(deps, packets) arrayLike are all just arrays of objectLike Parameters: Name Type Description deps Object dependencies for processing packets Array.&lt;Object&gt; packets to emit Source: handlers/Worldstate.js, line 97 Returns: object(s) to emit from arrayLike processing Type Object | Array.&lt;Object&gt; between(a, b, c) Validate that b is between a and c Parameters: Name Type Description a Date The first Date, should be the last time things were updated b Date The second Date, should be the activation time of an event c Date The third Date, should be the start time of this update cycle Source: utilities/index.js, line 50 Returns: if the event date is between the server start time and the last update time Type boolean checkOverrides(key, data) Find overrides for the provided key Parameters: Name Type Description key string worldsate field to find overrides data Object data corresponding to the key from provided worldstate Source: handlers/Worldstate.js, line 53 Returns: overrided key Type string fromNow(d [, now]) Returns the number of milliseconds between now and a given date Parameters: Name Type Argument Description d string The date from which the current time will be subtracted now function &lt;optional&gt; A function that returns the current UNIX time in milliseconds Source: utilities/index.js, line 58 Returns: Type number groupBy(array, field) Group an array by a field value Parameters: Name Type Description array Array.&lt;Object&gt; array of objects to broup field string field to group by Source: utilities/index.js, line 29 Returns: [description] Type Object initCycleStart(deps) Set up current cycle start if it's not been intiated Parameters: Name Type Description deps Object dependencies for processing Source: handlers/Worldstate.js, line 112 kuvaProcessing(deps, packets) Process kuva fields Parameters: Name Type Description deps Object dependencies for processing packets Array.&lt;Object&gt; packets to emit Source: handlers/Worldstate.js, line 69 Returns: object(s) to emit from kuva stuff Type Object | Array.&lt;Object&gt; parseNew(deps) Parse new events from the provided worldstate Parameters: Name Type Description deps Object dependencies to parse out events Source: handlers/Worldstate.js, line 123 Returns: packet(s) to emit Type Packet | Array.&lt;Packet&gt; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Classes Classes RSS TwitterCache Worldstate WSCache × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Worldstate Emitter Suuuper simple emitter for worldstate events. Very opinionated decisions on what events and event names, as well as Emitter Events Emitter Event Emit key description RSS rss New forum post from DE Worldstate ws:update New Worldstate event Tweet tweet New tweet from one of the selected accounts Twitter Accounts Warframe (warframe) Digital Extremes (digitalextremes) [DE]Pablo (pablo) Cameron Rogers (cameron) [DE]Rebecca (rebecca) [DE]Steve (steve) [DE]Danielle (danielle) [DE]Megan (megan) [DE]George (george) [DE]Maciej (maciej) [DE]Sheldon (sheldon) [DE]Marcus (narc) [DE]Helen (helen) Tobiah (me) (tobiah) WF Discord (wfdiscord) Twitter Events tweet retweet reply quote RSS Feeds Players helping Players PC Updates PC Announcements PS4 Updates PS4 Announcements XB1 Updates XB1 Announcements Switch Updates Switch Announcements News Developers Workshop Staff Replies [DE]Rebecca [DE]Danielle [DE]Drew [DE]Glen [DE]Taylor [DE]Steve [DE]Helen [DE]Saske [DE]Kaz [DE]Pablo [DE]Connor [DE]Marcus [DE]George [DE]Bear Other Methods Method Params Output getRss -- Map of RSS feeds with url and items getWorldstate platform, locale Worldstate objects -- platform Defaults to pc. One of pc, ps4, xb1, swi. -- locale Defaults to en. Any of the locales included in worldstate-data * Denote required Help &amp; Contact × Search results Close "},"RSS.html":{"id":"RSS.html","title":"Class: RSS","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Class: RSS RSS RSS Emitter, leverages [rss-feed-emitter](https://npmjs.org/package/rss-feed-emitter) new RSS(eventEmitter) Set up emitting events for warframe forum entries Parameters: Name Type Description eventEmitter EventEmitter Emitter to send events from Source: handlers/RSS.js, line 16 × Search results Close "},"TwitterCache.html":{"id":"TwitterCache.html","title":"Class: TwitterCache","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Class: TwitterCache TwitterCache Twitter event handler new TwitterCache(eventEmitter) Create a new Twitter self-updating cache Parameters: Name Type Description eventEmitter EventEmitter emitter to push new tweets to Source: handlers/Twitter.js, line 64 Methods &lt;async&gt; getData() Get the current data or a promise with the current data Source: handlers/Twitter.js, line 171 Returns: either the current data if it's not updating, or the promise returning the new data Type Promise.&lt;Object&gt; | Object &lt;async&gt; getParseableData() Get data able to be parsed from twitter. Source: handlers/Twitter.js, line 129 Returns: Twieets Type Promise.&lt;Array.&lt;Object&gt;&gt; onError(error) Handle errors that arise while fetching data from twitter Parameters: Name Type Description error Source: handlers/Twitter.js, line 157 &lt;async&gt; update() Force the cache to update Source: handlers/Twitter.js, line 107 Returns: the currently updating promise. Type Promise × Search results Close "},"Worldstate.html":{"id":"Worldstate.html","title":"Class: Worldstate","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Class: Worldstate Worldstate Handler for worldstate data new Worldstate(eventEmitter, platform, locale) Set up listening for specific platform and locale if provided. Parameters: Name Type Description eventEmitter EventEmitter Emitter to push new worldstate events to platform string Platform to watch (optional) locale string Locale (actually just language) to watch Source: handlers/Worldstate.js, line 182 Methods emit(id, packet) Emit an event with given id Parameters: Name Type Description id string Id of the event to emit packet Object Data packet to emit Source: handlers/Worldstate.js, line 285 get( [platform] [, locale]) get a specific worldstate version Parameters: Name Type Argument Default Description platform string &lt;optional&gt; 'pc' Platform of the worldstate locale string &lt;optional&gt; 'en' Locale of the worldsttate Source: handlers/Worldstate.js, line 301 Throws: when the platform or locale aren't tracked and aren't updated Type Error Returns: Worldstate corresponding to provided data Type Object parseEvents(worldstate, platform [, language]) Parse new worldstate events Parameters: Name Type Argument Default Description worldstate Object worldstate to find packets from platform string platform the worldstate corresponds to language string &lt;optional&gt; 'en' langauge of the worldstate (defaults to 'en') Source: handlers/Worldstate.js, line 255 setupParsedEvents() Set up listeners for the parsed worldstate updates Source: handlers/Worldstate.js, line 242 setUpRawEmitters() Set up emitting raw worldstate data Source: handlers/Worldstate.js, line 201 × Search results Close "},"WSCache.html":{"id":"WSCache.html","title":"Class: WSCache","body":" Worldstate Emitter Classes RSSTwitterCacheWorldstateWSCache Global arrayLikebetweencheckOverridesfromNowgroupByinitCycleStartkuvaProcessinglastUpdatedparseNew Class: WSCache WSCache Warframe WorldState Cache - store and retrieve current worldstate data new WSCache(platform, language, kuvaCache, sentientCache, eventEmitter) Set up a cache checking for data and updates to a specific worldstate set Parameters: Name Type Description platform string Platform to track language string Langauge/translation to track kuvaCache JSONCache Cache of kuva data, provided by Semlar sentientCache JSONCache Cache of sentient outpost data, provided by Semlar eventEmitter Eventemitter Emitter to push new worldstate updates to Source: utilities/WSCache.js, line 17 Members data Get the latest worldstate data from this cache Source: utilities/WSCache.js, line 39 data Set the current data, aslso parses and emits data Source: utilities/WSCache.js, line 47 twitter Set the current twitter data for the worldstate Source: utilities/WSCache.js, line 65 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
